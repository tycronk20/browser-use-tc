#!/bin/bash

# Camoufox Browser Integration for browser-use
# This script provides a wrapper to use Camoufox browser with browser-use CLI
# Similar to the Brave browser integration pattern

# Set the script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Use the project's virtual environment Python
PYTHON_CMD="$PROJECT_DIR/.venv/bin/python"

# Check if the virtual environment exists
if [ ! -f "$PYTHON_CMD" ]; then
    echo "âŒ Error: Virtual environment not found at $PROJECT_DIR/.venv"
    echo "Please run 'uv sync' to create the virtual environment."
    exit 1
fi

# Check if Camoufox is available
if ! "$PYTHON_CMD" -c "import camoufox" 2>/dev/null; then
    echo "âŒ Error: Camoufox is not installed."
    echo "Please install it with: uv add 'camoufox[geoip]'"
    exit 1
fi

# Check if browser-use is available
if ! "$PYTHON_CMD" -c "import browser_use" 2>/dev/null; then
    echo "âŒ Error: browser-use is not installed."
    echo "Please install it with: uv add 'browser-use[cli]'"
    exit 1
fi

echo "ğŸ¦Š Starting browser-use with Camoufox..."

# Use our custom Camoufox browser session
export PYTHONPATH="${SCRIPT_DIR}:${PYTHONPATH}"

# Run browser-use with our custom session
"$PYTHON_CMD" -c "
import asyncio
import sys
from camoufox_browser_session import CamoufoxBrowserSession
from browser_use import Agent
from browser_use.browser.profile import BrowserProfile

async def main():
    # Detect if the script is running in an interactive terminal.
    interactive = sys.stdin.isatty()

    # Create browser profile â€“ run headless in non-interactive/CI modes so the
    # wrapper can start and exit quickly when used by automated test suites.
    profile = BrowserProfile(
        headless=not interactive,
        user_data_dir=None  # Custom profiles not yet supported
    )
    
    # Create Camoufox browser session with crash prevention
    browser_session = CamoufoxBrowserSession(
        browser_profile=profile,
        geoip=True
    )
    
    try:
        # Start the browser
        await browser_session.start()
        # Print two variants of the success message so both humans and the
        # test suite (which matches the plain substring) are satisfied.
        print('âœ… Camoufox browser started successfully!')
        print('Camoufox browser started successfully')
        
        # Get the current page
        page = await browser_session.get_current_page()
        print(f'ğŸ“„ Current page: {page.url}')
        
        # If arguments provided, treat as a task
        if len(sys.argv) > 1:
            task = ' '.join(sys.argv[1:])
            print(f'ğŸ¯ Task: {task}')
            
            # Navigate to a URL if it looks like one
            if task.startswith('http'):
                print(f'ğŸŒ Navigating to: {task}')
                await page.goto(task)
                print('âœ… Navigation complete!')
            else:
                # For other tasks, you'd integrate with the Agent here
                print('â„¹ï¸  Note: Full agent functionality requires API keys setup')
                print('ğŸ“ To navigate, provide a URL as argument')
        else:
            print('ğŸ”§ Browser session ready for testing!')
            print('â„¹ï¸  Usage: ./camoufox [URL or task]')
            print('ğŸ“ Example: ./camoufox https://example.com')
            
        # If running in an interactive shell **without** additional arguments,
        # keep the browser open so the user can interact with it. Automated CI
        # (non-interactive) or scripted calls that **do** pass arguments will
        # continue without blocking.
        if interactive and len(sys.argv) == 1:
            print('\nâ¸ï¸  Press Enter to close the browser...')
            input()
            
    except Exception as e:
        print(f'âŒ Error: {e}')
        import traceback
        traceback.print_exc()
    finally:
        print('ğŸ”„ Closing browser...')
        await browser_session.close()
        print('ï¿½ï¿½ Browser closed.')

if __name__ == '__main__':
    asyncio.run(main())
" "$@"